{"version":3,"file":"teleswap-tines-sdk.cjs.production.min.js","sources":["../src/Utils.ts","../src/Graph.ts","../src/PrimaryPools.ts","../src/CLPool.ts","../src/StableSwapPool.ts","../src/deprecated/MultiRouterTypes.ts","../src/MultiRouter.ts","../src/deprecated/MultiRouterMath.ts"],"sourcesContent":["import { BigNumber } from \"@ethersproject/bignumber\";\n\nexport function ASSERT(f: () => boolean, t?: string) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!f() && t) console.error(t);\n    }\n  }\n\nlet DEBUG_MODE = false\nexport function DEBUG(f: () => any) {\n  if (DEBUG_MODE) f()\n}\nexport function DEBUG_MODE_ON(on: boolean) {\n  DEBUG_MODE = on\n}\n  \n  export function closeValues(a: number, b: number, accuracy: number): boolean {\n    if (accuracy === 0) return a === b;\n    if (a < 1 / accuracy) return Math.abs(a - b) <= 10;\n    return Math.abs(a / b - 1) < accuracy;\n  }\n  \n  export function calcSquareEquation(\n    a: number,\n    b: number,\n    c: number\n  ): [number, number] {\n    const D = b * b - 4 * a * c;\n    console.assert(D >= 0, `Discriminant is negative! ${a} ${b} ${c}`);\n    const sqrtD = Math.sqrt(D);\n    return [(-b - sqrtD) / 2 / a, (-b + sqrtD) / 2 / a];\n  }\n  \n  // returns such x > 0 that f(x) = out or 0 if there is no such x or f defined not everywhere\n  // hint - approximation of x to spead up the algorithm\n  // f assumed to be continues monotone growth function defined everywhere\n  export function revertPositive(\n    f: (x: number) => number,\n    out: number,\n    hint = 1\n  ) {\n    try {\n      if (out <= f(0)) return 0;\n      let min, max;\n      if (f(hint) > out) {\n        min = hint / 2;\n        while (f(min) > out) min /= 2;\n        max = min * 2;\n      } else {\n        max = hint * 2;\n        while (f(max) < out) max *= 2;\n        min = max / 2;\n      }\n  \n      while (max / min - 1 > 1e-4) {\n        const x0: number = (min + max) / 2;\n        const y0 = f(x0);\n        if (out === y0) return x0;\n        if (out < y0) max = x0;\n        else min = x0;\n      }\n      return (min + max) / 2;\n    } catch (e) {\n      return 0;\n    }\n  }\n  \n  export function getBigNumber(\n    value: number\n  ): BigNumber {\n    const v = Math.abs(value)\n    if (v < Number.MAX_SAFE_INTEGER) return BigNumber.from(Math.round(value));\n  \n    const exp = Math.floor(Math.log(v) / Math.LN2);\n    console.assert(exp >= 51, \"Internal Error 314\");\n    const shift = exp - 51;\n    const mant = Math.round(v / Math.pow(2, shift));\n    const res = BigNumber.from(mant).mul(BigNumber.from(2).pow(shift));\n    return value > 0 ? res : res.mul(-1);\n  }\n  ","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { RPool, RToken } from \"./PrimaryPools\";\nimport {ASSERT, getBigNumber, closeValues, DEBUG} from \"./Utils\";\n\n// Routing info about each one swap\nexport interface RouteLeg {\n  poolAddress: string       // which pool use for swap\n  poolFee: number\n\n  tokenFrom: RToken         // from what token to swap\n  tokenTo: RToken           // to what token \n\n  assumedAmountIn: number   // assumed number of input token for swapping\n  assumedAmountOut: number  // assumed number of output token after swapping\n\n  swapPortion: number       // for router contract\n  absolutePortion: number   // to depict at webpage for user\n}\n\nexport enum RouteStatus {\n  Success = \"Success\",\n  NoWay = \"NoWay\",\n  Partial = \"Partial\",\n}\n\nexport interface MultiRoute {\n  status: RouteStatus;\n  fromToken: RToken;\n  toToken: RToken;\n  primaryPrice?: number;\n  swapPrice?: number;\n  priceImpact?: number;\n  amountIn: number;\n  amountInBN: BigNumber;\n  amountOut: number;\n  amountOutBN: BigNumber;\n  legs: RouteLeg[];\n  gasSpent: number;\n  totalAmountOut: number;\n  totalAmountOutBN: BigNumber;\n}\n\nexport class Edge {\n  pool: RPool;\n  vert0: Vertice;\n  vert1: Vertice;\n\n  canBeUsed: boolean;\n  direction: boolean;\n  amountInPrevious: number;   // How many liquidity were passed from vert0 to vert1\n  amountOutPrevious: number;  // How many liquidity were passed from vert0 to vert1\n  spentGas: number            // How much gas was spent for this edge\n  spentGasNew: number         //  How much gas was will be spent for this edge\n  bestEdgeIncome: number;     // debug data\n\n\n  constructor(p: RPool, v0: Vertice, v1: Vertice) {\n    this.pool = p;\n    this.vert0 = v0;\n    this.vert1 = v1;\n    this.amountInPrevious = 0;\n    this.amountOutPrevious = 0;\n    this.canBeUsed = true;\n    this.direction = true;\n    this.spentGas = 0;\n    this.spentGasNew = 0;\n    this.bestEdgeIncome = 0;\n  }\n\n  cleanTmpData() {\n    this.amountInPrevious = 0;\n    this.amountOutPrevious = 0;\n    this.canBeUsed = true;\n    this.direction = true;\n    this.spentGas = 0;\n    this.spentGasNew = 0;\n    this.bestEdgeIncome = 0;\n  }\n\n  reserve(v: Vertice): BigNumber {\n    return v === this.vert0 ? this.pool.reserve0 : this.pool.reserve1\n  }\n\n  calcOutput(v: Vertice, amountIn: number): {out: number, gasSpent: number} {\n    let res, gas;\n    if (v === this.vert1) {\n      if (this.direction) {\n        if (amountIn < this.amountOutPrevious) {\n          const {inp, gasSpent} = this.pool.calcInByOut(this.amountOutPrevious - amountIn, true)\n          res = this.amountInPrevious - inp\n          gas = gasSpent\n        } else {\n          const {out, gasSpent} = this.pool.calcOutByIn(amountIn - this.amountOutPrevious, false)\n          res = out + this.amountInPrevious\n          gas = gasSpent\n        }\n      } else {\n        const {out, gasSpent} = this.pool.calcOutByIn(this.amountOutPrevious + amountIn, false)\n        res = out - this.amountInPrevious;\n        gas = gasSpent\n      }\n    } else {\n      if (this.direction) {\n        const {out, gasSpent} = this.pool.calcOutByIn(this.amountInPrevious + amountIn, true)\n        res = out - this.amountOutPrevious\n        gas = gasSpent\n      } else {\n        if (amountIn < this.amountInPrevious) {\n          const {inp, gasSpent} = this.pool.calcInByOut(this.amountInPrevious - amountIn, false)\n          res = this.amountOutPrevious - inp\n          gas = gasSpent\n        } else {\n          const {out, gasSpent} = this.pool.calcOutByIn(amountIn - this.amountInPrevious, true)\n          res = out + this.amountOutPrevious\n          gas = gasSpent\n        }\n      }\n    }\n\n    // this.testApply(v, amountIn, out);\n\n    return {out: res, gasSpent: gas - this.spentGas};\n  }\n\n  calcInput(v: Vertice, amountOut: number): {inp: number, gasSpent: number}  {\n    let res, gas;\n    if (v === this.vert1) {\n      if (!this.direction) {\n        if (amountOut < this.amountOutPrevious) {\n          const {out, gasSpent}  = this.pool.calcOutByIn(this.amountOutPrevious - amountOut, false)\n          res = this.amountInPrevious - out\n          gas = gasSpent\n        } else {\n          const {inp, gasSpent} = this.pool.calcInByOut(amountOut - this.amountOutPrevious, true)\n          res = inp + this.amountInPrevious\n          gas = gasSpent\n        }\n      } else {\n        const {inp, gasSpent} = this.pool.calcInByOut(this.amountOutPrevious + amountOut, true)\n        res = inp - this.amountInPrevious\n        gas = gasSpent\n      }\n    } else {\n      if (!this.direction) {\n        const {inp, gasSpent} = this.pool.calcInByOut(this.amountInPrevious + amountOut, false)\n        res = inp - this.amountOutPrevious\n        gas = gasSpent\n      } else {\n        if (amountOut < this.amountInPrevious) {\n          const {out, gasSpent} = this.pool.calcOutByIn(this.amountInPrevious - amountOut, true)\n          res = this.amountOutPrevious - out\n          gas = gasSpent\n        } else {\n          const {inp, gasSpent} = this.pool.calcInByOut(amountOut - this.amountInPrevious, false)\n          res = inp + this.amountOutPrevious\n          gas = gasSpent\n        }\n      }\n    }\n\n    // this.testApply(v, amountIn, out);\n\n    return {inp: res, gasSpent: gas - this.spentGas};\n  }\n\n  checkMinimalLiquidityExceededAfterSwap(from: Vertice, amountOut: number): boolean {\n    if (from === this.vert0) {\n      const r1 = parseInt(this.pool.reserve1.toString())\n      if (this.direction) {\n        return r1 - amountOut - this.amountOutPrevious < this.pool.minLiquidity;\n      } else {\n        return r1 - amountOut + this.amountOutPrevious < this.pool.minLiquidity;\n      }\n    } else {\n      const r0 = parseInt(this.pool.reserve0.toString())\n      if (this.direction) {\n        return r0 - amountOut + this.amountInPrevious < this.pool.minLiquidity;\n      } else {\n        return r0 - amountOut - this.amountInPrevious < this.pool.minLiquidity;\n      }\n    }\n  }\n\n  // doesn't used in production - just for testing\n  testApply(from: Vertice, amountIn: number, amountOut: number) {\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0)\n    const inPrev = this.direction ? this.amountInPrevious : -this.amountInPrevious\n    const outPrev = this.direction ? this.amountOutPrevious : -this.amountOutPrevious\n    const to = from.getNeibour(this)\n    let directionNew,\n      amountInNew = 0,\n      amountOutNew = 0\n    if (to) {\n      const inInc = from === this.vert0 ? amountIn : -amountOut\n      const outInc = from === this.vert0 ? amountOut : -amountIn\n      const inNew = inPrev + inInc\n      const outNew = outPrev + outInc\n      if (inNew * outNew < 0) console.log('333')\n      console.assert(inNew * outNew >= 0)\n      if (inNew >= 0) {\n        directionNew = true\n        amountInNew = inNew\n        amountOutNew = outNew\n      } else {\n        directionNew = false\n        amountInNew = -inNew\n        amountOutNew = -outNew\n      }\n    } else console.error('Error 221')\n\n    if (directionNew) {\n      const calc = this.pool.calcOutByIn(amountInNew, true).out;\n      const res = closeValues(amountOutNew, calc, 1e-6);\n      if (!res)\n        console.log(\n          \"Err 225-1 !!\",\n          amountOutNew,\n          calc,\n          Math.abs(calc / amountOutNew - 1)\n        );\n      return res;\n    } else {\n      const calc = this.pool.calcOutByIn(amountOutNew, false).out;\n      const res = closeValues(amountInNew, calc, 1e-6);\n      if (!res)\n        console.log(\n          \"Err 225-2!!\",\n          amountInNew,\n          calc,\n          Math.abs(calc / amountInNew - 1)\n        );\n      return res;\n    }\n  }\n\n  applySwap(from: Vertice) {\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0)\n    const inPrev = this.direction ? this.amountInPrevious : -this.amountInPrevious\n    const outPrev = this.direction ? this.amountOutPrevious : -this.amountOutPrevious\n    const to = from.getNeibour(this)\n    if (to) {\n      const inInc = from === this.vert0 ? from.bestIncome : -to.bestIncome\n      const outInc = from === this.vert0 ? to.bestIncome : -from.bestIncome\n      const inNew = inPrev + inInc\n      const outNew = outPrev + outInc\n      console.assert(inNew * outNew >= 0)\n      if (inNew >= 0) {\n        this.direction = true\n        this.amountInPrevious = inNew\n        this.amountOutPrevious = outNew\n      } else {\n        this.direction = false\n        this.amountInPrevious = -inNew\n        this.amountOutPrevious = -outNew\n      }\n    } else console.error(\"Error 221\");\n    this.spentGas = this.spentGasNew\n\n    ASSERT(() => {\n      if (this.direction)\n        return closeValues(\n          this.amountOutPrevious,\n          this.pool.calcOutByIn(this.amountInPrevious, this.direction).out,\n          1e-6\n        );\n      else {\n        return closeValues(\n          this.amountInPrevious,\n          this.pool.calcOutByIn(this.amountOutPrevious, this.direction).out,\n          1e-6\n        );\n      }\n    }, `Error 225`)\n  }\n}\n\nexport class Vertice {\n  token: RToken\n  edges: Edge[]\n\n  price: number\n  gasPrice: number\n\n  bestIncome: number // temp data used for findBestPath algorithm\n  gasSpent: number // temp data used for findBestPath algorithm\n  bestTotal: number // temp data used for findBestPath algorithm\n  bestSource?: Edge // temp data used for findBestPath algorithm\n  checkLine: number // debug data\n\n  constructor(t: RToken) {\n    this.token = t\n    this.edges = []\n    this.price = 0\n    this.gasPrice = 0\n    this.bestIncome = 0\n    this.gasSpent = 0\n    this.bestTotal = 0\n    this.bestSource = undefined\n    this.checkLine = -1\n  }\n\n  cleanTmpData() {\n    this.bestIncome = 0\n    this.gasSpent = 0\n    this.bestTotal = 0\n    this.bestSource = undefined\n    this.checkLine = -1\n  }\n\n  getNeibour(e?: Edge) {\n    if (!e) return\n    return e.vert0 === this ? e.vert1 : e.vert0\n  }\n\n  getOutputEdges(): Edge[] {\n    return this.edges.filter((e) => {\n      if (!e.canBeUsed) return false\n      if (e.amountInPrevious === 0) return false\n      if (e.direction !== (e.vert0 === this)) return false\n      return true\n    })\n  }\n\n  getInputEdges(): Edge[] {\n    return this.edges.filter((e) => {\n      if (!e.canBeUsed) return false\n      if (e.amountInPrevious === 0) return false\n      if (e.direction === (e.vert0 === this)) return false\n      return true\n    })\n  }\n}\n\nexport class Graph {\n  vertices: Vertice[]\n  edges: Edge[]\n  tokens: Map<string, Vertice>\n\n  constructor(pools: RPool[], baseToken: RToken, gasPrice: number) {\n    this.vertices = [];\n    this.edges = [];\n    this.tokens = new Map();\n    pools.forEach((p) => {\n      const v0 = this.getOrCreateVertice(p.token0)\n      const v1 = this.getOrCreateVertice(p.token1)\n      const edge = new Edge(p, v0, v1)\n      v0.edges.push(edge)\n      v1.edges.push(edge)\n      this.edges.push(edge)\n    })\n    const baseVert = this.tokens.get(baseToken.address)\n    if (baseVert) {\n      this.setPricesStable(baseVert, 1, gasPrice)\n    }\n  }\n\n  cleanTmpData() {\n    this.edges.forEach(e => e.cleanTmpData())\n    this.vertices.forEach(v => v.cleanTmpData())\n  }\n\n  // Set prices using greedy algorithm\n  setPricesStable(from: Vertice, price: number, gasPrice: number) {\n    this.vertices.forEach(v => v.price = 0) // initialization\n    from.price = price\n    from.gasPrice = gasPrice\n    \n    const edgeValues = new Map<Edge, number>()\n    const value = (e: Edge): number => edgeValues.get(e) as number\n    \n    function addVertice(v: Vertice) {\n      const newEdges = v.edges.filter(e => v.getNeibour(e)?.price == 0)\n      newEdges.forEach(e => edgeValues.set(e, v.price*parseInt(e.reserve(v).toString())) )\n      newEdges.sort((e1, e2) => value(e1) - value(e2))\n      const res: Edge[] = []\n      while (nextEdges.length && newEdges.length) {\n        if (value(nextEdges[0]) < value(newEdges[0])) res.push(nextEdges.shift() as Edge)  \n        else res.push(newEdges.shift() as Edge)\n      }\n      nextEdges = [...res, ...nextEdges, ...newEdges]\n    }\n    \n    let nextEdges: Edge[] = []\n    addVertice(from)\n    while (nextEdges.length > 0) {\n      const bestEdge = nextEdges.pop() as Edge\n      const [vFrom, vTo] = bestEdge.vert1.price !== 0\n        ? [bestEdge.vert1, bestEdge.vert0] : [bestEdge.vert0, bestEdge.vert1]\n      if (vTo.price !== 0) continue\n      let p = bestEdge.pool.calcCurrentPriceWithoutFee(vFrom === bestEdge.vert1);\n      vTo.price = vFrom.price*p\n      vTo.gasPrice = vFrom.gasPrice/p\n      addVertice(vTo)\n    }\n  }\n\n  // Set prices by search in depth\n  setPrices(from: Vertice, price: number, gasPrice: number) {\n    if (from.price !== 0) return\n    from.price = price\n    from.gasPrice = gasPrice\n    const edges = from.edges\n      .map((e): [Edge, number] => [e, parseInt(e.reserve(from).toString())])\n      .sort(([_1, r1], [_2, r2]) => r2 - r1)\n    edges.forEach(([e, _]) => {\n      const v = e.vert0 === from ? e.vert1 : e.vert0;\n      if (v.price !== 0) return;\n      let p = e.pool.calcCurrentPriceWithoutFee(from === e.vert1);\n      this.setPrices(v, price * p, gasPrice / p);\n    });\n  }\n\n  getOrCreateVertice(token: RToken) {\n    let vert = this.tokens.get(token.address)\n    if (vert) return vert\n    vert = new Vertice(token)\n    this.vertices.push(vert)\n    this.tokens.set(token.address, vert)\n    return vert\n  }\n\n  /*exportPath(from: RToken, to: RToken) {\n\n    const fromVert = this.tokens.get(from) as Vertice\n    const toVert = this.tokens.get(to) as Vertice\n    const initValue = (fromVert.bestIncome * fromVert.price) / toVert.price\n\n    const route = new Set<Edge>()\n    for (let v = toVert; v !== fromVert; v = v.getNeibour(v.bestSource) as Vertice) {\n      if (v.bestSource) route.add(v.bestSource)\n    }\n\n    function edgeStyle(e: Edge) {\n      const finish = e.vert1.bestSource === e\n      const start = e.vert0.bestSource === e\n      let label\n      if (e.bestEdgeIncome === -1) label = 'label: \"low_liq\"'\n      if (e.bestEdgeIncome !== 0) label = `label: \"${print((e.bestEdgeIncome / initValue - 1) * 100, 3)}%\"`\n      const edgeValue = route.has(e) ? 'value: 2' : undefined\n      let arrow\n      if (finish && start) arrow = 'arrows: \"from,to\"'\n      if (finish) arrow = 'arrows: \"to\"'\n      if (start) arrow = 'arrows: \"from\"'\n      return ['', label, edgeValue, arrow].filter((a) => a !== undefined).join(', ')\n    }\n\n    function print(n: number, digits: number) {\n      let out\n      if (n === 0) out = '0'\n      else {\n        const n0 = n > 0 ? n : -n\n        const shift = digits - Math.ceil(Math.log(n0) / Math.LN10)\n        if (shift <= 0) out = `${Math.round(n0)}`\n        else {\n          const mult = Math.pow(10, shift)\n          out = `${Math.round(n0 * mult) / mult}`\n        }\n        if (n < 0) out = -out\n      }\n      return out\n    }\n\n    function nodeLabel(v: Vertice) {\n      const value = (v.bestIncome * v.price) / toVert.price\n      const income = `${print(value, 3)}`\n      const total = `${print(v.bestTotal, 3)}`\n      // const income = `${print((value/initValue-1)*100, 3)}%`\n      // const total = `${print((v.bestTotal/initValue-1)*100, 3)}%`\n      const checkLine = v.checkLine === -1 ? undefined : `${v.checkLine}`\n      return [checkLine, income, total].filter((a) => a !== undefined).join(':')\n    }\n\n    const nodes = `var nodes = new vis.DataSet([\n      ${this.vertices.map((t) => `{ id: ${t.token.name}, label: \"${nodeLabel(t)}\"}`).join(',\\n\\t\\t')}\n    ]);\\n`\n    const edges = `var edges = new vis.DataSet([\n      ${this.edges\n        .map((p) => `{ from: ${p.vert0.token.name}, to: ${p.vert1.token.name}${edgeStyle(p)}}`)\n        .join(',\\n\\t\\t')}\n    ]);\\n`\n    const data = `var data = {\n        nodes: nodes,\n        edges: edges,\n    };\\n`\n\n    // TODO: This should be removed, this pacakge will not be installable on a client while this remains.\n    const fs = require(\"fs\");\n    fs.writeFileSync(\n      \"D:/Info/Notes/GraphVisualization/data.js\",\n      nodes + edges + data\n    );\n  }*/\n\n  findBestPathExactIn(\n    from: RToken,\n    to: RToken,\n    amountIn: number,\n    _gasPrice?: number\n  ):\n    | {\n        path: Edge[]\n        output: number\n        gasSpent: number\n        totalOutput: number\n      }\n    | undefined {\n    const start = this.tokens.get(from.address)\n    const finish = this.tokens.get(to.address)\n    if (!start || !finish) return\n\n    const gasPrice = _gasPrice !== undefined ? _gasPrice : finish.gasPrice\n\n    this.edges.forEach((e) => {\n      e.bestEdgeIncome = 0\n      e.spentGasNew = 0\n    });\n    this.vertices.forEach((v) => {\n      v.bestIncome = 0\n      v.gasSpent = 0\n      v.bestTotal = 0\n      v.bestSource = undefined\n      v.checkLine = -1\n    })\n    start.bestIncome = amountIn\n    start.bestTotal = amountIn\n    const processedVert = new Set<Vertice>()\n    const nextVertList = [start] // TODO: Use sorted Set!\n\n    let debug_info = ``\n    let checkLine = 0\n    for (;;) {\n      let closestVert: Vertice | undefined\n      let closestTotal: number | undefined\n      let closestPosition = 0\n      nextVertList.forEach((v, i) => {\n        if (closestTotal === undefined || v.bestTotal > closestTotal) {\n          closestTotal = v.bestTotal\n          closestVert = v\n          closestPosition = i\n        }\n      })\n\n      if (!closestVert) return\n\n      closestVert.checkLine = checkLine++\n\n      if (closestVert === finish) {\n        const bestPath = []\n        for (let v: Vertice | undefined = finish; v?.bestSource; v = v.getNeibour(v.bestSource)) {\n          bestPath.unshift(v.bestSource)\n        }\n        DEBUG(() => console.log(debug_info)) \n        return {\n          path: bestPath,\n          output: finish.bestIncome,\n          gasSpent: finish.gasSpent,\n          totalOutput: finish.bestTotal,\n        }\n      }\n      nextVertList.splice(closestPosition, 1)\n\n      closestVert.edges.forEach((e) => {\n        const v2 = closestVert === e.vert0 ? e.vert1 : e.vert0\n        if (processedVert.has(v2)) return\n        let newIncome: number, gas\n        try {\n          const {out, gasSpent} = e.calcOutput(closestVert as Vertice, (closestVert as Vertice).bestIncome)\n          if (!isFinite(out) || !isFinite(gasSpent))   // Math errors protection\n            return\n          newIncome = out\n          gas = gasSpent\n        } catch (e) {\n          // Any arithmetic error or out-of-liquidity\n          return\n        }\n        if (e.checkMinimalLiquidityExceededAfterSwap(closestVert as Vertice, newIncome)) {\n          e.bestEdgeIncome = -1\n          return\n        }\n        const newGasSpent = (closestVert as Vertice).gasSpent + gas\n        const price = v2.price / finish.price\n        const newTotal = newIncome * price - newGasSpent * gasPrice\n\n        console.assert(e.bestEdgeIncome === 0, \"Error 373\");\n        e.bestEdgeIncome = newIncome * price;\n        e.spentGasNew = e.spentGas + gas;\n\n        if (!v2.bestSource) nextVertList.push(v2)\n        if (!v2.bestSource || newTotal > v2.bestTotal) {\n          DEBUG(() => {\n            const st = closestVert?.token == from ? '*' : ''\n            const fn = v2?.token == to ? '*' : ''\n            debug_info += `${st}${closestVert?.token.name}->${v2.token.name}${fn} ${v2.bestIncome} -> ${newIncome}\\n`\n          })\n          v2.bestIncome = newIncome\n          v2.gasSpent = newGasSpent\n          v2.bestTotal = newTotal\n          v2.bestSource = e          \n        }\n      })\n      processedVert.add(closestVert)\n    }\n  }\n\n  findBestPathExactOut(\n    from: RToken,\n    to: RToken,\n    amountOut: number,\n    _gasPrice?: number\n  ):\n    | {\n        path: Edge[]\n        input: number\n        gasSpent: number\n        totalInput: number\n      }\n    | undefined {\n    const start = this.tokens.get(to.address)\n    const finish = this.tokens.get(from.address)\n    if (!start || !finish) return\n\n    const gasPrice = _gasPrice !== undefined ? _gasPrice : finish.gasPrice\n\n    this.edges.forEach((e) => {\n      e.bestEdgeIncome = 0\n      e.spentGasNew = 0\n    });\n    this.vertices.forEach((v) => {\n      v.bestIncome = 0\n      v.gasSpent = 0\n      v.bestTotal = 0\n      v.bestSource = undefined\n      v.checkLine = -1\n    })\n    start.bestIncome = amountOut\n    start.bestTotal = amountOut\n    const processedVert = new Set<Vertice>()\n    const nextVertList = [start] // TODO: Use sorted Set!\n\n    let debug_info = ''\n    let checkLine = 0\n    for (;;) {\n      let closestVert: Vertice | undefined\n      let closestTotal: number | undefined\n      let closestPosition = 0\n      nextVertList.forEach((v, i) => {\n        if (closestTotal === undefined || v.bestTotal < closestTotal) {\n          closestTotal = v.bestTotal\n          closestVert = v\n          closestPosition = i\n        }\n      })\n\n      if (!closestVert) return\n\n      closestVert.checkLine = checkLine++\n\n      if (closestVert === finish) {\n        const bestPath = []\n        for (let v: Vertice | undefined = finish; v?.bestSource; v = v.getNeibour(v.bestSource)) {\n          bestPath.push(v.bestSource)\n        }\n        DEBUG(() => console.log(debug_info))\n        return {\n          path: bestPath,\n          input: finish.bestIncome,\n          gasSpent: finish.gasSpent,\n          totalInput: finish.bestTotal,\n        }\n      }\n      nextVertList.splice(closestPosition, 1)\n\n      closestVert.edges.forEach((e) => {\n        const v2 = closestVert === e.vert0 ? e.vert1 : e.vert0\n        if (processedVert.has(v2)) return\n        let newIncome: number, gas\n        try {\n          const {inp, gasSpent} = e.calcInput(closestVert as Vertice, (closestVert as Vertice).bestIncome)\n          if (!isFinite(inp) || !isFinite(gasSpent))   // Math errors protection\n            return\n          if (inp < 0) return // No enouph liquidity in the pool\n          newIncome = inp\n          gas = gasSpent\n        } catch (e) {\n          // Any arithmetic error or out-of-liquidity\n          return\n        }\n        const newGasSpent = (closestVert as Vertice).gasSpent + gas\n        const price = v2.price / finish.price\n        const newTotal = newIncome * price + newGasSpent * gasPrice\n\n        console.assert(e.bestEdgeIncome === 0, \"Error 373\");\n        e.bestEdgeIncome = newIncome * price;\n        e.spentGasNew = e.spentGas + gas;\n\n        if (!v2.bestSource) nextVertList.push(v2)\n        if (!v2.bestSource || newTotal < v2.bestTotal) {\n          DEBUG(() => {\n            const st = v2?.token == from ? '*' : ''\n            const fn = closestVert?.token == to ? '*' : ''\n            debug_info += `${st}${closestVert?.token.name}<-${v2.token.name}${fn} ${v2.bestIncome} -> ${newIncome}\\n`\n          })\n          v2.bestIncome = newIncome\n          v2.gasSpent = newGasSpent\n          v2.bestTotal = newTotal\n          v2.bestSource = e\n        }\n      })\n      processedVert.add(closestVert)\n    }\n  }\n\n  addPath(from: Vertice | undefined, to: Vertice | undefined, path: Edge[]) {\n    let _from = from\n    path.forEach((e) => {\n      if (_from) {\n        e.applySwap(_from)\n        _from = _from.getNeibour(e)\n      } else {\n        console.error('Unexpected 315')\n      }\n    })\n\n    ASSERT(() => {\n      const res = this.vertices.every((v) => {\n        let total = 0\n        let totalModule = 0\n        v.edges.forEach((e) => {\n          if (e.vert0 === v) {\n            if (e.direction) {\n              total -= e.amountInPrevious\n            } else {\n              total += e.amountInPrevious\n            }\n            totalModule += e.amountInPrevious\n          } else {\n            if (e.direction) {\n              total += e.amountOutPrevious\n            } else {\n              total -= e.amountOutPrevious\n            }\n            totalModule += e.amountOutPrevious\n          }\n        })\n        if (v === from) return total <= 0\n        if (v === to) return total >= 0\n        if (totalModule === 0) return total === 0\n        return Math.abs(total / totalModule) < 1e10\n      })\n      return res\n    }, 'Error 290')\n  }\n\n  getPrimaryPriceForPath(from: Vertice, path: Edge[]): number {\n    let p = 1\n    let prevToken = from\n    path.forEach( edge => {\n      const direction = edge.vert0 === prevToken\n      const edgePrice = edge.pool.calcCurrentPriceWithoutFee(direction)\n      p *= edgePrice\n      prevToken = prevToken.getNeibour(edge) as Vertice\n    })\n    return p\n  }\n\n  findBestRouteExactIn(from: RToken, to: RToken, amountIn: number, mode: number | number[]): MultiRoute {\n    let routeValues = []\n    if (Array.isArray(mode)) {\n      const sum = mode.reduce((a, b) => a + b, 0)\n      routeValues = mode.map((e) => e / sum)\n    } else {\n      for (let i = 0; i < mode; ++i) routeValues.push(1 / mode)\n    }\n\n    this.edges.forEach((e) => {\n      e.amountInPrevious = 0\n      e.amountOutPrevious = 0\n      e.direction = true\n    })\n    let output = 0\n    let gasSpentInit = 0\n    //let totalOutput = 0\n    let totalrouted = 0\n    let primaryPrice\n    let step\n    for (step = 0; step < routeValues.length; ++step) {\n      const p = this.findBestPathExactIn(from, to, amountIn * routeValues[step])\n      if (!p) {\n        break\n      } else {\n        output += p.output\n        gasSpentInit += p.gasSpent\n        //totalOutput += p.totalOutput\n        this.addPath(this.tokens.get(from.address), this.tokens.get(to.address), p.path)\n        totalrouted += routeValues[step]\n        if (step === 0) {\n          primaryPrice = this.getPrimaryPriceForPath(this.tokens.get(from.address) as Vertice, p.path)\n        }\n      }\n    }\n    if (step == 0)\n      return {\n        status: RouteStatus.NoWay,\n        fromToken: from,\n        toToken: to,\n        amountIn: 0,\n        amountInBN: BigNumber.from(0),\n        amountOut: 0,\n        amountOutBN: BigNumber.from(0),\n        legs: [],\n        gasSpent: 0,\n        totalAmountOut: 0,\n        totalAmountOutBN: BigNumber.from(0),\n      }\n    let status\n    if (step < routeValues.length) status = RouteStatus.Partial\n    else status = RouteStatus.Success\n\n    const fromVert = this.tokens.get(from.address) as Vertice\n    const toVert = this.tokens.get(to.address) as Vertice\n    const {legs, gasSpent, topologyWasChanged} = this.getRouteLegs(fromVert, toVert)\n    console.assert(gasSpent <= gasSpentInit, 'Internal Error 491')\n\n    if (topologyWasChanged) {\n      output = this.calcLegsAmountOut(legs, amountIn)\n    }\n\n    let swapPrice, priceImpact\n    try {\n      swapPrice = output/amountIn\n      priceImpact = primaryPrice !== undefined? 1- swapPrice/primaryPrice : undefined\n    } catch(e) { /* skip division by 0 errors*/}\n\n    return {\n      status,\n      fromToken: from,\n      toToken: to,\n      primaryPrice,\n      swapPrice,\n      priceImpact,\n      amountIn: amountIn * totalrouted,\n      amountInBN: getBigNumber(amountIn * totalrouted),\n      amountOut: output,\n      amountOutBN: getBigNumber(output),\n      legs,\n      gasSpent,\n      totalAmountOut: output - gasSpent * toVert.gasPrice,\n      totalAmountOutBN: getBigNumber(output - gasSpent * toVert.gasPrice),\n    }\n  }\n\n  findBestRouteExactOut(from: RToken, to: RToken, amountOut: number, mode: number | number[]): MultiRoute {\n    let routeValues = []\n    if (Array.isArray(mode)) {\n      const sum = mode.reduce((a, b) => a + b, 0)\n      routeValues = mode.map((e) => e / sum)\n    } else {\n      for (let i = 0; i < mode; ++i) routeValues.push(1 / mode)\n    }\n\n    this.edges.forEach((e) => {\n      e.amountInPrevious = 0\n      e.amountOutPrevious = 0\n      e.direction = true\n    })\n    let input = 0\n    let gasSpentInit = 0\n    //let totalOutput = 0\n    let totalrouted = 0\n    let primaryPrice\n    let step\n    for (step = 0; step < routeValues.length; ++step) {\n      const p = this.findBestPathExactOut(from, to, amountOut * routeValues[step])\n      if (!p) {\n        break\n      } else {\n        input += p.input\n        gasSpentInit += p.gasSpent\n        //totalOutput += p.totalOutput\n        this.addPath(this.tokens.get(from.address), this.tokens.get(to.address), p.path)\n        totalrouted += routeValues[step]\n        if (step === 0) {\n          primaryPrice = this.getPrimaryPriceForPath(this.tokens.get(from.address) as Vertice, p.path)\n        }\n      }\n    }\n    if (step == 0)\n      return {\n        status: RouteStatus.NoWay,\n        fromToken: from,\n        toToken: to,\n        amountIn: 0,\n        amountInBN: BigNumber.from(0),\n        amountOut: 0,\n        amountOutBN: BigNumber.from(0),\n        legs: [],\n        gasSpent: 0,\n        totalAmountOut: 0,\n        totalAmountOutBN: BigNumber.from(0),\n      }\n    let status\n    if (step < routeValues.length) status = RouteStatus.Partial\n    else status = RouteStatus.Success\n\n    const fromVert = this.tokens.get(from.address) as Vertice\n    const toVert = this.tokens.get(to.address) as Vertice\n    const {legs, gasSpent, topologyWasChanged} = this.getRouteLegs(fromVert, toVert)\n    console.assert(gasSpent <= gasSpentInit, 'Internal Error 491')\n\n    if (topologyWasChanged) {\n      input = this.calcLegsAmountIn(legs, amountOut) ///\n    }\n\n    let swapPrice, priceImpact\n    try {\n      swapPrice = amountOut/input\n      priceImpact = primaryPrice !== undefined? 1- swapPrice/primaryPrice : undefined\n    } catch(e) { /* skip division by 0 errors*/}\n\n    return {\n      status,\n      fromToken: from,\n      toToken: to,\n      primaryPrice,\n      swapPrice,\n      priceImpact,\n      amountIn: input,\n      amountInBN: getBigNumber(input),\n      amountOut: amountOut * totalrouted,\n      amountOutBN: getBigNumber(amountOut * totalrouted),\n      legs,\n      gasSpent,\n      totalAmountOut: amountOut - gasSpent * toVert.gasPrice,\n      totalAmountOutBN: getBigNumber(amountOut - gasSpent * toVert.gasPrice),\n    }\n  }\n\n  getRouteLegs(from: Vertice, to: Vertice): {\n    legs: RouteLeg[],\n    gasSpent: number,\n    topologyWasChanged: boolean\n  } {\n    const {vertices, topologyWasChanged} = this.cleanTopology(from, to)\n    const legs: RouteLeg[] = []\n    let gasSpent = 0\n    vertices.forEach((n) => {\n      const outEdges = n.getOutputEdges().map((e) => {\n        const from = this.edgeFrom(e)\n        return from ? [e, from.vert, from.amount] : [e]\n      })\n\n      let outAmount = outEdges.reduce((a, b) => a + (b[2] as number), 0)\n      if (outAmount <= 0) return\n\n      const total = outAmount\n      outEdges.forEach((e, i) => {\n        const p = e[2] as number\n        const quantity = i + 1 === outEdges.length ? 1 : p / outAmount\n        const edge = e[0] as Edge\n        legs.push({\n          poolAddress: edge.pool.address,\n          poolFee: edge.pool.fee,\n          tokenFrom: n.token,\n          tokenTo: (n.getNeibour(edge) as Vertice).token,\n          assumedAmountIn: edge.direction ? edge.amountInPrevious : edge.amountOutPrevious,\n          assumedAmountOut:  edge.direction ? edge.amountOutPrevious : edge.amountInPrevious,\n          swapPortion: quantity,\n          absolutePortion: p / total,\n        })\n        gasSpent += (e[0] as Edge).pool.swapGasCost\n        outAmount -= p\n      })\n      console.assert(outAmount / total < 1e-12, 'Error 281')\n    })\n    return {legs, gasSpent, topologyWasChanged}\n  }\n\n  edgeFrom(e: Edge): {vert: Vertice, amount: number} | undefined {\n    if (e.amountInPrevious === 0) return undefined\n    return e.direction ? {vert: e.vert0, amount: e.amountInPrevious} : {vert: e.vert1, amount: e.amountOutPrevious}\n  }\n\n  // TODO: make full test coverage!\n  calcLegsAmountOut(legs: RouteLeg[], amountIn: number) {\n    const amounts = new Map<string, number>()\n    amounts.set(legs[0].tokenFrom.address, amountIn)\n    legs.forEach((l) => {\n      const vert = this.tokens.get(l.tokenFrom.address);\n      console.assert(vert !== undefined, \"Internal Error 570\");\n      const edge = (vert as Vertice).edges.find(\n        (e) => e.pool.address === l.poolAddress\n      );\n      console.assert(edge !== undefined, \"Internel Error 569\");\n      const pool = (edge as Edge).pool;\n      const direction = vert === (edge as Edge).vert0;\n\n      const inputTotal = amounts.get(l.tokenFrom.address);\n      console.assert(inputTotal !== undefined, \"Internal Error 564\");\n      const input = (inputTotal as number) * l.swapPortion;\n      amounts.set(l.tokenFrom.address, (inputTotal as number) - input);\n      const output = pool.calcOutByIn(input, direction).out;\n\n      const vertNext = (vert as Vertice).getNeibour(edge) as Vertice;\n      const prevAmount = amounts.get(vertNext.token.address);\n      amounts.set(vertNext.token.address, (prevAmount || 0) + output);\n    });\n    return amounts.get(legs[legs.length-1].tokenTo.address) || 0;\n  }\n\n  // TODO: make full test coverage!\n  calcLegsAmountIn(legs: RouteLeg[], amountOut: number) {\n    const totalOutputAssumed = new Map<string, number>()\n    legs.forEach(l => {\n      const prevValue = totalOutputAssumed.get(l.tokenFrom.address) || 0\n      totalOutputAssumed.set(l.tokenFrom.address, prevValue + l.assumedAmountOut)\n    })\n\n    const amounts = new Map<string, number>()\n    amounts.set(legs[legs.length-1].tokenTo.address, amountOut)\n    for (let i = legs.length - 1; i >= 0; --i) {\n      const l = legs[i]\n      const vert = this.tokens.get(l.tokenTo.address);\n      console.assert(vert !== undefined, \"Internal Error 884\");\n      const edge = (vert as Vertice).edges.find(\n        (e) => e.pool.address === l.poolAddress\n      );\n      console.assert(edge !== undefined, \"Internel Error 888\");\n      const pool = (edge as Edge).pool;\n      const direction = vert === (edge as Edge).vert1;\n\n      const outputTotal = amounts.get(l.tokenTo.address);\n      console.assert(outputTotal !== undefined, \"Internal Error 893\");\n      const totalAssumed = totalOutputAssumed.get(l.tokenFrom.address)\n      console.assert(totalAssumed !== undefined, \"Internal Error 903\");\n      const output = (outputTotal as number) * l.assumedAmountOut / (totalAssumed as number);\n      const input = pool.calcInByOut(output, direction).inp;\n\n      const vertNext = (vert as Vertice).getNeibour(edge) as Vertice;\n      const prevAmount = amounts.get(vertNext.token.address);\n      amounts.set(vertNext.token.address, (prevAmount || 0) + input);\n    };\n    return amounts.get(legs[0].tokenFrom.address) || 0;\n  }\n\n  // removes all cycles if there are any, then removes all dead end could appear after cycle removing\n  // Returns clean result topologically sorted\n  cleanTopology(from: Vertice, to: Vertice): {vertices: Vertice[], topologyWasChanged: boolean} {\n    let topologyWasChanged = false\n    let result = this.topologySort(from, to)\n    if (result.status !== 2) {\n      topologyWasChanged = true\n      console.assert(result.status === 0, 'Internal Error 554')\n      while (result.status === 0) {\n        this.removeWeakestEdge(result.vertices)\n        result = this.topologySort(from, to)\n      }\n      if (result.status === 3) {\n        this.removeDeadEnds(result.vertices)\n        result = this.topologySort(from, to)\n      }\n      console.assert(result.status === 2, 'Internal Error 563')\n      if (result.status !== 2) return {vertices: [], topologyWasChanged}\n    }\n    return {vertices: result.vertices, topologyWasChanged}\n  }\n\n  removeDeadEnds(verts: Vertice[]) {\n    verts.forEach((v) => {\n      v.getInputEdges().forEach((e) => {\n        e.canBeUsed = false\n      })\n    })\n  }\n\n  removeWeakestEdge(verts: Vertice[]) {\n    let minVert: Vertice, minVertNext: Vertice\n    let minOutput = Number.MAX_VALUE\n    verts.forEach((v1, i) => {\n      const v2 = i === 0 ? verts[verts.length - 1] : verts[i - 1]\n      let out = 0\n      v1.getOutputEdges().forEach((e) => {\n        if (v1.getNeibour(e) !== v2) return\n        out += e.direction ? e.amountOutPrevious : e.amountInPrevious\n      })\n      if (out < minOutput) {\n        minVert = v1\n        minVertNext = v2\n        minOutput = out\n      }\n    })\n    // @ts-ignore\n    minVert.getOutputEdges().forEach((e) => {\n      if (minVert.getNeibour(e) !== minVertNext) return\n      e.canBeUsed = false\n    })\n  }\n\n  // topological sort\n  // if there is a cycle - returns [0, <List of envolved vertices in the cycle>]\n  // if there are no cycles but deadends- returns [3, <List of all envolved deadend vertices>]\n  // if there are no cycles or deadends- returns [2, <List of all envolved vertices topologically sorted>]\n  topologySort(from: Vertice, to: Vertice): {status: number, vertices: Vertice[]} {\n    // undefined or 0 - not processed, 1 - in process, 2 - finished, 3 - dedend\n    const vertState = new Map<Vertice, number>()\n    const vertsFinished: Vertice[] = []\n    const foundCycle: Vertice[] = []\n    const foundDeadEndVerts: Vertice[] = []\n\n    // 0 - cycle was found and created, return\n    // 1 - during cycle creating\n    // 2 - vertex is processed ok\n    // 3 - dead end vertex\n    function topSortRecursive(current: Vertice): number {\n      const state = vertState.get(current)\n      if (state === 2 || state === 3) return state\n      if (state === 1) {\n        console.assert(foundCycle.length == 0, 'Internal Error 566')\n        foundCycle.push(current)\n        return 1\n      }\n      vertState.set(current, 1)\n\n      let successors2Exist = false\n      const outEdges = current.getOutputEdges()\n      for (let i = 0; i < outEdges.length; ++i) {\n        const e = outEdges[i]\n        const res = topSortRecursive(current.getNeibour(e) as Vertice)\n        if (res === 0) return 0\n        if (res === 1) {\n          if (foundCycle[0] === current) return 0\n          else {\n            foundCycle.push(current)\n            return 1\n          }\n        }\n        if (res === 2) successors2Exist = true // Ok successors\n      }\n      if (successors2Exist) {\n        console.assert(current !== to, 'Internal Error 589')\n        vertsFinished.push(current)\n        vertState.set(current, 2)\n        return 2\n      } else {\n        if (current !== to) {\n          foundDeadEndVerts.push(current)\n          vertState.set(current, 3)\n          return 3\n        }\n        vertsFinished.push(current)\n        vertState.set(current, 2)\n        return 2\n      }\n    }\n\n    const res = topSortRecursive(from)\n    if (res === 0) return {status: 0, vertices: foundCycle}\n    if (foundDeadEndVerts.length) return {status: 3, vertices: foundDeadEndVerts}\n    ASSERT(() => {\n      if (vertsFinished[0] !== to) return false\n      if (vertsFinished[vertsFinished.length - 1] !== from) return false\n      return true\n    }, 'Internal Error 614')\n    if (res === 2) return {status: 2, vertices: vertsFinished.reverse()}\n    console.assert(true, 'Internal Error 612')\n    return {status: 1, vertices: []}\n  }\n}","import { BigNumber } from '@ethersproject/bignumber'\nimport { getBigNumber, revertPositive } from './Utils'\n\nexport const TYPICAL_SWAP_GAS_COST = 60_000\nexport const TYPICAL_MINIMAL_LIQUIDITY = 1000\n\nexport interface RToken {\n  name: string\n  address: string\n}\n\nexport abstract class RPool {\n  readonly address: string\n  readonly token0: RToken\n  readonly token1: RToken\n  readonly fee: number\n  reserve0: BigNumber\n  reserve1: BigNumber\n  readonly minLiquidity: number\n  readonly swapGasCost: number\n\n  constructor(\n    address: string,\n    token0: RToken,\n    token1: RToken,\n    fee: number,\n    reserve0: BigNumber,\n    reserve1: BigNumber,\n    minLiquidity = TYPICAL_MINIMAL_LIQUIDITY,\n    swapGasCost = TYPICAL_SWAP_GAS_COST\n  ) {\n    this.address = address\n    ;(this.token0 = token0), (this.token1 = token1)\n    this.fee = fee\n    this.minLiquidity = minLiquidity\n    this.swapGasCost = swapGasCost\n    this.reserve0 = reserve0\n    this.reserve1 = reserve1\n  }\n\n  updateReserves(res0: BigNumber, res1: BigNumber) {\n    this.reserve0 = res0\n    this.reserve1 = res1\n  }\n\n  // Returns [<output amount>, <gas consumption estimation>]\n  abstract calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number}\n  abstract calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number}\n  abstract calcCurrentPriceWithoutFee(direction: boolean): number\n  // abstract calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number;\n  // abstract calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean, hint: number): number;\n}\n\nexport class ConstantProductRPool extends RPool {\n  reserve0Number: number\n  reserve1Number: number\n\n  constructor(address: string, token0: RToken, token1: RToken, fee: number, reserve0: BigNumber, reserve1: BigNumber) {\n    super(address, token0, token1, fee, reserve0, reserve1)\n    this.reserve0Number = parseInt(reserve0.toString())\n    this.reserve1Number = parseInt(reserve1.toString())\n  }\n\n  updateReserves(res0: BigNumber, res1: BigNumber) {\n    this.reserve0 = res0\n    this.reserve0Number = parseInt(res0.toString())\n    this.reserve1 = res1\n    this.reserve1Number = parseInt(res1.toString())\n  }\n\n  calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number} {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    return {out: (y * amountIn) / (x / (1 - this.fee) + amountIn), gasSpent: this.swapGasCost}\n  }\n\n  calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number} {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    if ((y-amountOut) < this.minLiquidity)  // not possible swap\n      return {inp: Number.POSITIVE_INFINITY, gasSpent: this.swapGasCost}\n\n    let input = (x * amountOut) / (1 - this.fee) / (y - amountOut)\n    return {inp: input, gasSpent: this.swapGasCost}\n  }\n\n  calcCurrentPriceWithoutFee(direction: boolean): number {\n    return this.calcPrice(0, direction, false)\n  }\n\n  calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1\n    const xf = x / oneMinusFee\n    return (y * xf) / (xf + amountIn) / (xf + amountIn)\n  }\n\n  calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean): number {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1\n    const xf = x / oneMinusFee\n    return Math.sqrt(y * xf * price) - xf // TODO: or y*xf/price ???\n  }\n\n  getLiquidity() {\n    return Math.sqrt(this.reserve0Number * this.reserve1Number)\n  }\n}\n\nexport class HybridRPool extends RPool {\n  readonly A: number\n  readonly A_PRECISION = 100\n  D: BigNumber // set it to 0 if reserves are changed !!\n\n  constructor(\n    address: string,\n    token0: RToken,\n    token1: RToken,\n    fee: number,\n    A: number,\n    reserve0: BigNumber,\n    reserve1: BigNumber\n  ) {\n    super(address, token0, token1, fee, reserve0, reserve1)\n    this.A = A\n    this.D = BigNumber.from(0)\n  }\n\n  updateReserves(res0: BigNumber, res1: BigNumber) {\n    this.D = BigNumber.from(0)\n    this.reserve0 = res0\n    this.reserve1 = res1\n  }\n\n  computeLiquidity(): BigNumber {\n    if (!this.D.eq(0)) return this.D // already calculated\n\n    const r0 = this.reserve0\n    const r1 = this.reserve1\n\n    if (r0.isZero() && r1.isZero()) return BigNumber.from(0)\n\n    const s = r0.add(r1)\n    const nA = BigNumber.from(this.A * 2)\n    let prevD\n    let D = s\n    for (let i = 0; i < 256; i++) {\n      const dP = D.mul(D).div(r0).mul(D).div(r1).div(4)\n      prevD = D\n      D = nA\n        .mul(s)\n        .div(this.A_PRECISION)\n        .add(dP.mul(2))\n        .mul(D)\n        .div(nA.div(this.A_PRECISION).sub(1).mul(D).add(dP.mul(3)))\n      if (D.sub(prevD).abs().lte(1)) {\n        break\n      }\n    }\n    this.D = D\n    return D\n  }\n\n  computeY(x: BigNumber): BigNumber {\n    const D = this.computeLiquidity()\n\n    const nA = this.A * 2\n\n    let c = D.mul(D)\n      .div(x.mul(2))\n      .mul(D)\n      .div((nA * 2) / this.A_PRECISION)\n    let b = D.mul(this.A_PRECISION).div(nA).add(x)\n\n    let yPrev\n    let y = D\n    for (let i = 0; i < 256; i++) {\n      yPrev = y\n\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D))\n      if (y.sub(yPrev).abs().lte(1)) {\n        break\n      }\n    }\n    return y\n  }\n\n  calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number} {\n    const xBN = direction ? this.reserve0 : this.reserve1\n    const yBN = direction ? this.reserve1 : this.reserve0\n    const xNewBN = xBN.add(getBigNumber(amountIn * (1 - this.fee)))\n    const yNewBN = this.computeY(xNewBN)\n    const dy = parseInt(yBN.sub(yNewBN).toString())\n\n    return {out: dy, gasSpent: this.swapGasCost}\n  }\n\n  calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number} {\n    const xBN = direction ? this.reserve0 : this.reserve1\n    const yBN = direction ? this.reserve1 : this.reserve0\n    let yNewBN = yBN.sub(getBigNumber(amountOut))\n    if (yNewBN.lt(1))\n      // lack of precision\n      yNewBN = BigNumber.from(1)\n\n    const xNewBN = this.computeY(yNewBN)\n    let input = Math.round(parseInt(xNewBN.sub(xBN).toString()) / (1 - this.fee))\n\n    //if (input < 1) input = 1\n    return {inp: input, gasSpent: this.swapGasCost}\n  }\n\n  calcCurrentPriceWithoutFee(direction: boolean): number {\n    return this.calcPrice(0, direction, false)\n  }\n\n  calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number {\n    const xBN = direction ? this.reserve0 : this.reserve1\n    const x = parseInt(xBN.toString())\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1\n    const D = parseInt(this.computeLiquidity().toString())\n    const A = this.A / this.A_PRECISION\n    const xI = x + amountIn\n    const b = 4 * A * xI + D - 4 * A * D\n    const ac4 = (D * D * D) / xI\n    const Ds = Math.sqrt(b * b + 4 * A * ac4)\n    const res = (0.5 - (2 * b - ac4 / xI) / Ds / 4) * oneMinusFee\n    return res\n  }\n\n  calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean, hint = 1): number {\n    // TODO:  (x:number) => this.calcPrice(x, !direction, takeFeeIntoAccount)  ???\n    return revertPositive((x: number) => 1 / this.calcPrice(x, direction, takeFeeIntoAccount), price, hint)\n  }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { RPool, RToken, TYPICAL_MINIMAL_LIQUIDITY, TYPICAL_SWAP_GAS_COST } from \"./PrimaryPools\";\n\nexport const CL_MIN_TICK = -887272\nexport const CL_MAX_TICK = -CL_MIN_TICK - 1\n\nexport interface CLTick {\n  index: number\n  DLiquidity: number\n}\n\nexport class CLRPool extends RPool {\n  tickSpacing: number\n  liquidity: number\n  sqrtPrice: number\n  nearestTick: number\n  ticks: CLTick[]\n\n  constructor(      \n    address: string,\n    token0: RToken,\n    token1: RToken,\n    fee: number,\n    tickSpacing: number,\n    reserve0: BigNumber,\n    reserve1: BigNumber,\n    liquidity: number,\n    sqrtPrice: number,\n    nearestTick: number,\n    ticks: CLTick[]\n  ) {\n    super(      \n      address,\n      token0,\n      token1,\n      fee,\n      reserve0,\n      reserve1,\n      TYPICAL_MINIMAL_LIQUIDITY,\n      TYPICAL_SWAP_GAS_COST,\n    )\n    this.tickSpacing = tickSpacing\n    this.liquidity = liquidity\n    this.sqrtPrice = sqrtPrice\n    this.nearestTick = nearestTick\n    this.ticks = ticks\n    if (this.ticks.length === 0) {\n      this.ticks.push({ index: CL_MIN_TICK, DLiquidity: 0 })\n      this.ticks.push({ index: CL_MAX_TICK, DLiquidity: 0 })\n    }\n    if (this.ticks[0].index > CL_MIN_TICK) this.ticks.unshift({ index: CL_MIN_TICK, DLiquidity: 0 })\n    if (this.ticks[this.ticks.length - 1].index < CL_MAX_TICK) this.ticks.push({ index: CL_MAX_TICK, DLiquidity: 0 })\n  }\n\n  calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number} {\n    let nextTickToCross = direction ? this.nearestTick : this.nearestTick + 1\n    let currentPrice = this.sqrtPrice\n    let currentLiquidity = this.liquidity\n    let outAmount = 0\n    let input = amountIn\n  \n    while (input > 0) {\n      if (nextTickToCross < 0 || nextTickToCross >= this.ticks.length)\n        return {out: outAmount, gasSpent: this.swapGasCost}\n  \n      const nextTickPrice = Math.sqrt(Math.pow(1.0001, this.ticks[nextTickToCross].index))\n      // console.log('L, P, tick, nextP', currentLiquidity,\n      //     currentPrice, this.ticks[nextTickToCross].index, nextTickPrice);\n      let output = 0\n  \n      if (direction) {\n        const maxDx = (currentLiquidity * (currentPrice - nextTickPrice)) / currentPrice / nextTickPrice\n        //console.log('input, maxDx', input, maxDx);\n  \n        if (input <= maxDx) {\n          output = (currentLiquidity * currentPrice * input) / (input + currentLiquidity / currentPrice)\n          input = 0\n        } else {\n          output = currentLiquidity * (currentPrice - nextTickPrice)\n          currentPrice = nextTickPrice\n          input -= maxDx\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross--\n        }\n      } else {\n        const maxDy = currentLiquidity * (nextTickPrice - currentPrice)\n        //console.log('input, maxDy', input, maxDy);\n        if (input <= maxDy) {\n          output = input / currentPrice / (currentPrice + input / currentLiquidity)\n          input = 0\n        } else {\n          output = (currentLiquidity * (nextTickPrice - currentPrice)) / currentPrice / nextTickPrice\n          currentPrice = nextTickPrice\n          input -= maxDy\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross++\n        }\n      }\n  \n      outAmount += output * (1 - this.fee)\n      //console.log('out', outAmount);\n    }\n  \n    return {out: outAmount, gasSpent: this.swapGasCost}  // TODO: more accurate gas prediction \n  }\n\n  calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number} {  \n    let nextTickToCross = direction ? this.nearestTick : this.nearestTick + 1\n    let currentPrice = this.sqrtPrice\n    let currentLiquidity = this.liquidity\n    let input = 0\n    let outBeforeFee = amountOut/(1-this.fee)    \n\n    while (outBeforeFee > 0) {\n      if (nextTickToCross < 0 || nextTickToCross >= this.ticks.length)\n        return {inp: input, gasSpent: this.swapGasCost}\n  \n      const nextTickPrice = Math.sqrt(Math.pow(1.0001, this.ticks[nextTickToCross].index))\n      // console.log('L, P, tick, nextP', currentLiquidity,\n      //     currentPrice, this.ticks[nextTickToCross].index, nextTickPrice);\n  \n      if (direction) {\n        const maxDy = currentLiquidity * (currentPrice - nextTickPrice)\n        //console.log('input, maxDy', input, maxDy);\n        if (outBeforeFee <= maxDy) {\n          input += outBeforeFee / currentPrice / (currentPrice - outBeforeFee / currentLiquidity)\n          outBeforeFee = 0\n        } else {\n          input += (currentLiquidity * (currentPrice - nextTickPrice)) / currentPrice / nextTickPrice\n          currentPrice = nextTickPrice\n          outBeforeFee -= maxDy\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross--\n        }\n      } else {\n        const maxDx = (currentLiquidity * (nextTickPrice - currentPrice)) / currentPrice / nextTickPrice\n        //console.log('outBeforeFee, maxDx', outBeforeFee, maxDx);\n  \n        if (outBeforeFee <= maxDx) {\n          input += (currentLiquidity * currentPrice * outBeforeFee) / (currentLiquidity / currentPrice - outBeforeFee)\n          outBeforeFee = 0\n        } else {\n          input += currentLiquidity * (nextTickPrice - currentPrice)\n          currentPrice = nextTickPrice\n          outBeforeFee -= maxDx\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross++\n        }\n      }\n    }\n  \n    return {inp: input, gasSpent: this.swapGasCost}\n  }\n  \n  calcCurrentPriceWithoutFee(direction: boolean): number {\n    const p = this.sqrtPrice*this.sqrtPrice\n    return direction ? p : 1/p\n  }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { RPool, RToken} from \"./PrimaryPools\";\nimport { getBigNumber } from './Utils'\n\n// xy(xx+yy) = k\nexport class StableSwapRPool extends RPool {\n  k: BigNumber // set it to 0 if reserves are changed !!\n\n  constructor(address: string, token0: RToken, token1: RToken, fee: number, reserve0: BigNumber, reserve1: BigNumber) {\n    super(address, token0, token1, fee, reserve0, reserve1)\n    this.k = BigNumber.from(0)\n  }\n\n  updateReserves(res0: BigNumber, res1: BigNumber) {\n    this.k = BigNumber.from(0)\n    this.reserve0 = res0\n    this.reserve1 = res1\n  }\n\n  computeK(): BigNumber {\n    if (this.k.isZero()) {\n      const x = this.reserve0\n      const y = this.reserve1\n      this.k = x.mul(y).mul( x.mul(x).add(y.mul(y)) )\n    }\n    return this.k\n  }\n\n  computeY(x: BigNumber, yHint: BigNumber): BigNumber {\n    const k = this.computeK()\n    const x2 = x.shl(1)\n    const x3 = x.mul(3)\n    const xCube = x.mul(x).mul(x)\n    let yPrev = yHint, y = yHint\n    for (let i = 0; i < 255; ++i) {\n      const ySquare = y.mul(y)\n      const yCube = ySquare.mul(y)\n      y = yCube.mul(x2).add(k).div( ySquare.mul(x3).add(xCube) )\n      if (y.sub(yPrev).abs().lte(1)) break\n      yPrev = y\n    }\n    return y\n  }\n\n  calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number} {\n    const x = direction ? this.reserve0 : this.reserve1\n    const y = direction ? this.reserve1 : this.reserve0\n    const xNew = x.add(getBigNumber(Math.floor(amountIn * (1 - this.fee))))\n    const yNew = this.computeY(xNew, y)\n    const out = parseInt(y.sub(yNew).toString()) - 1    // with precision loss compensation\n    return {out: Math.max(out, 0), gasSpent: this.swapGasCost}\n  }\n\n  calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number} {\n    const x = direction ? this.reserve0 : this.reserve1\n    const y = direction ? this.reserve1 : this.reserve0\n    let yNew = y.sub(getBigNumber(Math.ceil(amountOut)))\n    if (yNew.lt(this.minLiquidity))  // not possible swap\n      return {inp: Number.POSITIVE_INFINITY, gasSpent: this.swapGasCost}\n\n    const xNew = this.computeY(yNew, x)\n    let input = Math.round(parseInt(xNew.sub(x).toString()) / (1 - this.fee)) + 1  // with precision loss compensation\n    return {inp: input, gasSpent: this.swapGasCost}\n  }\n\n  calcCurrentPriceWithoutFee(direction: boolean): number {\n    const calcDirection = this.reserve0.gt(this.reserve1)\n    const xBN = calcDirection ? this.reserve0 : this.reserve1\n    // TODO: make x = max(x, y)\n    const x = parseInt(xBN.toString())\n    const k = parseInt(this.computeK().toString())\n    const q = k/x/2\n    const qD = -q/x                           // devivative of q\n    const Q = Math.pow(x, 6)/27 + q*q\n    const QD = 6*Math.pow(x, 5)/27 + 2*q*qD   // derivative of Q\n    const sqrtQ = Math.sqrt(Q)\n    const sqrtQD = 1/2/sqrtQ*QD               // derivative of sqrtQ\n    const a = sqrtQ + q\n    const aD = sqrtQD + qD\n    const b = sqrtQ - q\n    const bD = sqrtQD - qD\n    const a3 = Math.pow(a, 1/3)\n    const a3D = 1/3*a3/a*aD\n    const b3 = Math.pow(b, 1/3)\n    const b3D = 1/3*b3/b*bD\n    const yD = a3D - b3D\n\n    // For testing\n    // const yBN = calcDirection ? this.reserve1 : this.reserve0\n    // const y = parseInt(yBN.toString())\n    // const yC= a3-b3\n    // console.assert(Math.abs(yC/y - 1) < 1e-8)\n    \n    return calcDirection == direction ? -yD : -1/yD\n  }\n\n}","import { BigNumber } from '@ethersproject/bignumber'\n\ninterface RToken {\n  name: string\n  address: string\n}\n\nexport enum PoolType {\n  ConstantProduct = 'ConstantProduct',\n  Weighted = 'Weighted',\n  Hybrid = 'Hybrid',\n  ConcentratedLiquidity = 'ConcentratedLiquidity',\n}\n\nexport interface PoolInfo {\n  address: string\n  token0: RToken\n  token1: RToken\n  type: PoolType\n  reserve0: BigNumber\n  reserve1: BigNumber\n  fee: number\n  minLiquidity: number\n  swapGasCost: number\n}\n\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\ntype PoolInfoWithDefaults = PartialBy<PoolInfo, 'minLiquidity' | 'swapGasCost'>\n\nexport class Pool {\n  address: string\n  token0: RToken\n  token1: RToken\n  type: PoolType\n  reserve0: BigNumber\n  reserve1: BigNumber\n  fee: number\n  minLiquidity: number\n  swapGasCost: number\n\n  constructor(_info: PoolInfoWithDefaults) {\n    const info = {\n      minLiquidity: 1000,\n      swapGasCost: 40_000,\n      ..._info,\n    }\n    this.address = info.address\n    this.token0 = info.token0\n    this.token1 = info.token1\n    this.type = info.type\n    this.reserve0 = info.reserve0\n    this.reserve1 = info.reserve1\n    this.fee = info.fee\n    this.minLiquidity = info.minLiquidity\n    this.swapGasCost = info.swapGasCost\n  }\n}\n\ntype PoolInfoNoType = Omit<PoolInfoWithDefaults, 'type'>\n\nexport class RConstantProductPool extends Pool {\n  constructor(info: PoolInfoNoType) {\n    super({\n      type: PoolType.ConstantProduct,\n      ...info,\n    })\n  }\n}\n\ntype HybridPoolInfo = PoolInfoNoType & { A: number }\n\nexport class RHybridPool extends Pool {\n  A: number\n  constructor(info: HybridPoolInfo) {\n    super({\n      type: PoolType.Hybrid,\n      ...info,\n    })\n    this.A = info.A\n  }\n}\n\ntype WeightedPoolInfo = PoolInfoNoType & { weight0: number; weight1: number }\n\nexport class RWeightedPool extends Pool {\n  weight0: number\n  weight1: number\n  constructor(info: WeightedPoolInfo) {\n    super({\n      type: PoolType.Weighted,\n      ...info,\n    })\n    this.weight0 = info.weight0\n    this.weight1 = info.weight1\n  }\n}\n\ninterface CLTick {\n  index: number\n  DLiquidity: number\n}\n\ninterface CLSpecific {\n  liquidity: number\n  sqrtPrice: number\n  nearestTick: number\n  ticks: CLTick[]\n}\n\ntype CLPoolInfo = Omit<PoolInfoNoType, 'reserve0' | 'reserve1'> & CLSpecific\n\nexport class RConcentratedLiquidityPool extends Pool {\n  liquidity: number\n  sqrtPrice: number\n  nearestTick: number\n  ticks: CLTick[]\n  constructor(info: CLPoolInfo) {\n    super({\n      type: PoolType.ConcentratedLiquidity,\n      reserve0: BigNumber.from(0),\n      reserve1: BigNumber.from(0),\n      ...info,\n    })\n    this.liquidity = info.liquidity\n    this.sqrtPrice = info.sqrtPrice\n    this.nearestTick = info.nearestTick\n    this.ticks = info.ticks\n  }\n}\n\n","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { MultiRoute, Graph, RouteStatus } from \"./Graph\";\nimport { RPool, RToken } from \"./PrimaryPools\";  \n\n// Assumes route is a single path\nfunction calcPriceImactWithoutFee(route: MultiRoute) {\n  if (route.primaryPrice === undefined || route.swapPrice === undefined) {\n    return undefined\n  } else {\n    let oneMinusCombinedFee = 1\n    route.legs.forEach(l => oneMinusCombinedFee *= (1-l.poolFee))\n    //const combinedFee = 1-oneMinusCombinedFee\n    return Math.max(0, 1-route.swapPrice/route.primaryPrice/oneMinusCombinedFee)\n  }\n}\n\nconst defaultFlowNumber = 12\nconst maxFlowNumber = 100\nfunction calcBestFlowNumber(bestSingleRoute: MultiRoute, amountIn: number, gasPriceIn?: number): number {\n  const priceImpact = calcPriceImactWithoutFee(bestSingleRoute)\n  if (!priceImpact) return defaultFlowNumber\n\n  const bestFlowAmount = Math.sqrt(bestSingleRoute.gasSpent*(gasPriceIn || 0)*amountIn/priceImpact)\n  const bestFlowNumber = Math.round(amountIn/bestFlowAmount)\n  if (!isFinite(bestFlowNumber)) return maxFlowNumber\n\n  const realFlowNumber = Math.max(1, Math.min(bestFlowNumber, maxFlowNumber))\n  return realFlowNumber\n}\n\nfunction getBetterRouteExactIn(route1: MultiRoute, route2: MultiRoute): MultiRoute {\n  if (route1.status == RouteStatus.NoWay) return route2\n  if (route2.status == RouteStatus.NoWay) return route1\n  if (route1.status == RouteStatus.Partial && route2.status == RouteStatus.Success) return route2\n  if (route2.status == RouteStatus.Partial && route1.status == RouteStatus.Success) return route1\n  return route1.totalAmountOut > route2.totalAmountOut ? route1 : route2\n}\n\nexport function findMultiRouteExactIn(\n  from: RToken,\n  to: RToken,\n  amountIn: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number,\n  flows?: number | number[]\n): MultiRoute {\n  if (amountIn instanceof BigNumber) {\n    amountIn = parseInt(amountIn.toString())\n  }\n\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (flows !== undefined) return g.findBestRouteExactIn(from, to, amountIn, flows)\n\n  const outSingle = g.findBestRouteExactIn(from, to, amountIn, 1)\n  // Possible optimization of timing\n  // if (g.findBestPathExactIn(from, to, amountIn/100 + 10_000, 0)?.gasSpent === 0) return outSingle\n  g.cleanTmpData()\n\n  const bestFlowNumber = calcBestFlowNumber(outSingle, amountIn, fromV?.gasPrice)\n  if (bestFlowNumber === 1) return outSingle\n\n  const outMulti = g.findBestRouteExactIn(from, to, amountIn, bestFlowNumber)\n  return getBetterRouteExactIn(outSingle, outMulti)\n}\n\nfunction getBetterRouteExactOut(route1: MultiRoute, route2: MultiRoute, gasPrice: number): MultiRoute {\n  if (route1.status == RouteStatus.NoWay) return route2\n  if (route2.status == RouteStatus.NoWay) return route1\n  if (route1.status == RouteStatus.Partial && route2.status == RouteStatus.Success) return route2\n  if (route2.status == RouteStatus.Partial && route1.status == RouteStatus.Success) return route1\n  const totalAmountIn1 = route1.amountIn + route1.gasSpent*gasPrice\n  const totalAmountIn2 = route2.amountIn + route2.gasSpent*gasPrice\n  return totalAmountIn1 < totalAmountIn2 ? route1 : route2\n}\n\nexport function findMultiRouteExactOut(\n  from: RToken,\n  to: RToken,\n  amountOut: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number,\n  flows?: number | number[]\n): MultiRoute {\n  if (amountOut instanceof BigNumber) {\n    amountOut = parseInt(amountOut.toString())\n  }\n\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (flows !== undefined) return g.findBestRouteExactOut(from, to, amountOut, flows)\n\n  const inSingle = g.findBestRouteExactOut(from, to, amountOut, 1)\n  // Possible optimization of timing\n  // if (g.findBestPathExactOut(from, to, amountOut/100 + 10_000, 0)?.gasSpent === 0) return inSingle\n  g.cleanTmpData()\n\n  const bestFlowNumber = calcBestFlowNumber(inSingle, inSingle.amountIn, fromV?.gasPrice)\n  if (bestFlowNumber === 1) return inSingle\n\n  const inMulti = g.findBestRouteExactOut(from, to, amountOut, bestFlowNumber)\n  return getBetterRouteExactOut(inSingle, inMulti, gasPrice)\n}\n\nexport function findSingleRouteExactIn(\n  from: RToken,\n  to: RToken,\n  amountIn: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number\n): MultiRoute {\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (amountIn instanceof BigNumber) {\n    amountIn = parseInt(amountIn.toString())\n  }\n\n  const out = g.findBestRouteExactIn(from, to, amountIn, 1)\n  return out\n}\n\nexport function findSingleRouteExactOut(\n  from: RToken,\n  to: RToken,\n  amountOut: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number\n): MultiRoute {\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (amountOut instanceof BigNumber) {\n    amountOut = parseInt(amountOut.toString())\n  }\n\n  const out = g.findBestRouteExactOut(from, to, amountOut, 1)\n  return out\n}\n\nexport function calcTokenPrices(pools: RPool[], baseToken: RToken): Map<RToken, number> {\n  const g = new Graph(pools, baseToken, 0)\n  const res = new Map<RToken, number>()\n  g.vertices.forEach(v => res.set(v.token, v.price))\n  return res\n}","import {\n  Pool,\n  PoolType,\n  RHybridPool,\n  RWeightedPool,\n} from './MultiRouterTypes'\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { getBigNumber, revertPositive } from \"../Utils\";\n\nconst A_PRECISION = 100\n\nconst DCacheBN = new Map<Pool, BigNumber>()\nexport function HybridComputeLiquidity(pool: RHybridPool): BigNumber {\n  const res = DCacheBN.get(pool)\n  if (res !== undefined) return res\n\n  const r0 = pool.reserve0\n  const r1 = pool.reserve1\n\n  if (r0.isZero() && r1.isZero()) {\n    DCacheBN.set(pool, BigNumber.from(0))\n    return BigNumber.from(0)\n  }\n  const s = r0.add(r1)\n\n  const nA = BigNumber.from(pool.A * 2)\n\n  let prevD\n\n  let D = s\n  for (let i = 0; i < 256; i++) {\n    const dP = D.mul(D).div(r0).mul(D).div(r1).div(4)\n    prevD = D\n    D = nA\n      .mul(s)\n      .div(A_PRECISION)\n      .add(dP.mul(2))\n      .mul(D)\n      .div(nA.div(A_PRECISION).sub(1).mul(D).add(dP.mul(3)))\n    if (D.sub(prevD).abs().lte(1)) {\n      break\n    }\n  }\n  DCacheBN.set(pool, D)\n  return D\n}\n\nexport function HybridgetY(pool: RHybridPool, x: BigNumber): BigNumber {\n  const D = HybridComputeLiquidity(pool)\n\n  const nA = pool.A * 2\n\n  let c = D.mul(D)\n    .div(x.mul(2))\n    .mul(D)\n    .div((nA * 2) / A_PRECISION)\n  let b = D.mul(A_PRECISION).div(nA).add(x)\n\n  let yPrev\n  let y = D\n  for (let i = 0; i < 256; i++) {\n    yPrev = y\n\n    y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D))\n    if (y.sub(yPrev).abs().lte(1)) {\n      break\n    }\n  }\n  return y\n}\n\nexport function calcOutByIn(pool: Pool, amountIn: number, direction = true): number {\n  const xBN = direction ? pool.reserve0 : pool.reserve1\n  const yBN = direction ? pool.reserve1 : pool.reserve0\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      return (y * amountIn) / (x / (1 - pool.fee) + amountIn)\n    }\n    case PoolType.Weighted: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      const wPool = pool as RWeightedPool\n      const weightRatio = direction ? wPool.weight0 / wPool.weight1 : wPool.weight1 / wPool.weight0\n      const actualIn = amountIn * (1 - pool.fee)\n      const out = y * (1 - Math.pow(x / (x + actualIn), weightRatio))\n      return out\n    }\n    case PoolType.Hybrid: {\n      // const xNew = x + amountIn*(1-pool.fee);\n      // const yNew = HybridgetY(pool, xNew);\n      // const dy = y - yNew;\n\n      const xNewBN = xBN.add(getBigNumber(amountIn * (1 - pool.fee)))\n      const yNewBN = HybridgetY(pool as RHybridPool, xNewBN)\n      const dy = parseInt(yBN.sub(yNewBN).toString())\n\n      return dy\n    }\n  }\n  return -1\n}\n\nexport class OutOfLiquidity extends Error {}\n\n\nexport function calcInByOut(pool: Pool, amountOut: number, direction: boolean): number {\n  let input = 0\n  const xBN = direction ? pool.reserve0 : pool.reserve1\n  const yBN = direction ? pool.reserve1 : pool.reserve0\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      input = (x * amountOut) / (1 - pool.fee) / (y - amountOut)\n      break\n    }\n    case PoolType.Weighted: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      const wPool = pool as RWeightedPool\n      const weightRatio = direction ? wPool.weight0 / wPool.weight1 : wPool.weight1 / wPool.weight0\n      input = x * (1 - pool.fee) * (Math.pow(1 - amountOut / y, -weightRatio) - 1)\n      break\n    }\n    case PoolType.Hybrid: {\n      let yNewBN = yBN.sub(getBigNumber(amountOut))\n      if (yNewBN.lt(1))\n        // lack of precision\n        yNewBN = BigNumber.from(1)\n\n      const xNewBN = HybridgetY(pool as RHybridPool, yNewBN)\n      input = Math.round(parseInt(xNewBN.sub(xBN).toString()) / (1 - pool.fee))\n\n      // const yNew = y - amountOut;\n      // const xNew = HybridgetY(pool, yNew);\n      // input = (xNew - x)/(1-pool.fee);\n      break\n    }\n    default:\n      console.error('Unknown pool type')\n  }\n\n  // ASSERT(() => {\n  //   const amount2 = calcOutByIn(pool, input, direction);\n  //   const res = closeValues(amountOut, amount2, 1e-6);\n  //   if (!res) console.log(\"Error 138:\", amountOut, amount2, Math.abs(amountOut/amount2 - 1));\n  //   return res;\n  // });\n  if (input < 1) input = 1\n  return input\n}\n\nexport function calcPrice(pool: Pool, amountIn: number, takeFeeIntoAccount = true): number {\n  const r0 = parseInt(pool.reserve0.toString())\n  const r1 = parseInt(pool.reserve1.toString())\n  const oneMinusFee = takeFeeIntoAccount ? 1 - pool.fee : 1\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = r0 / oneMinusFee\n      return (r1 * x) / (x + amountIn) / (x + amountIn)\n    }\n    case PoolType.Weighted: {\n      const wPool = pool as RWeightedPool\n      const weightRatio = wPool.weight0 / wPool.weight1\n      const x = r0 + amountIn * oneMinusFee\n      return (r1 * weightRatio * oneMinusFee * Math.pow(r0 / x, weightRatio)) / x\n    }\n    case PoolType.Hybrid: {\n      const hPool = pool as RHybridPool\n      const D = parseInt(HybridComputeLiquidity(hPool).toString())\n      const A = hPool.A / A_PRECISION\n      const x = r0 + amountIn\n      const b = 4 * A * x + D - 4 * A * D\n      const ac4 = (D * D * D) / x\n      const Ds = Math.sqrt(b * b + 4 * A * ac4)\n      const res = (0.5 - (2 * b - ac4 / x) / Ds / 4) * oneMinusFee\n      return res\n    }\n  }\n  return 0\n}\n\nfunction calcInputByPriceConstantMean(pool: RWeightedPool, price: number) {\n  const r0 = parseInt(pool.reserve0.toString())\n  const r1 = parseInt(pool.reserve1.toString())\n  const weightRatio = pool.weight0 / pool.weight1\n  const t = r1 * price * weightRatio * (1 - pool.fee) * Math.pow(r0, weightRatio)\n  return (Math.pow(t, 1 / (weightRatio + 1)) - r0) / (1 - pool.fee)\n}\n\nexport function calcInputByPrice(pool: Pool, priceEffective: number, hint = 1): number {\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const r0 = parseInt(pool.reserve0.toString())\n      const r1 = parseInt(pool.reserve1.toString())\n      const x = r0 / (1 - pool.fee)\n      const res = Math.sqrt(r1 * x * priceEffective) - x\n      return res\n    }\n    case PoolType.Weighted: {\n      const res = calcInputByPriceConstantMean(pool as RWeightedPool, priceEffective)\n      return res\n    }\n    case PoolType.Hybrid: {\n      return revertPositive((x: number) => 1 / calcPrice(pool, x), priceEffective, hint)\n    }\n  }\n  return 0\n}\n"],"names":["DEBUG_MODE","DEBUG","f","closeValues","a","b","accuracy","Math","abs","revertPositive","out","hint","min","max","x0","y0","e","getBigNumber","value","v","Number","MAX_SAFE_INTEGER","BigNumber","from","round","exp","floor","log","LN2","console","assert","shift","mant","pow","res","mul","RouteStatus","RPool","address","token0","token1","fee","reserve0","reserve1","minLiquidity","swapGasCost","this","updateReserves","res0","res1","ConstantProductRPool","_this","reserve0Number","parseInt","toString","reserve1Number","_inheritsLoose","_proto2","calcOutByIn","amountIn","direction","gasSpent","calcInByOut","amountOut","y","inp","POSITIVE_INFINITY","calcCurrentPriceWithoutFee","calcPrice","takeFeeIntoAccount","xf","calcInputByPrice","price","sqrt","getLiquidity","HybridRPool","A","_this2","D","_proto3","computeLiquidity","eq","r0","r1","isZero","prevD","s","add","nA","i","dP","div","A_PRECISION","sub","lte","computeY","x","yPrev","c","yBN","xNewBN","yNewBN","xBN","lt","oneMinusFee","xI","ac4","_this3","CLRPool","tickSpacing","liquidity","sqrtPrice","nearestTick","ticks","length","push","index","DLiquidity","unshift","_proto","nextTickToCross","currentPrice","currentLiquidity","outAmount","input","nextTickPrice","output","maxDx","maxDy","outBeforeFee","p","StableSwapRPool","k","computeK","yHint","x2","shl","x3","xCube","ySquare","xNew","yNew","ceil","calcDirection","gt","q","qD","Q","QD","sqrtQ","sqrtQD","aD","bD","yD","PoolType","Edge","v0","v1","pool","vert0","vert1","amountInPrevious","amountOutPrevious","canBeUsed","spentGas","spentGasNew","bestEdgeIncome","cleanTmpData","reserve","calcOutput","gas","calcInput","checkMinimalLiquidityExceededAfterSwap","testApply","directionNew","inPrev","outPrev","amountInNew","amountOutNew","getNeibour","inNew","outNew","error","calc","applySwap","to","bestIncome","Vertice","t","token","edges","gasPrice","bestTotal","bestSource","undefined","checkLine","getOutputEdges","filter","getInputEdges","Graph","pools","baseToken","vertices","tokens","Map","forEach","_this4","getOrCreateVertice","edge","baseVert","get","setPricesStable","edgeValues","addVertice","newEdges","set","sort","e1","e2","nextEdges","bestEdge","pop","vFrom","vTo","setPrices","map","_this5","vert","findBestPathExactIn","_gasPrice","start","finish","processedVert","Set","nextVertList","debug_info","closestVert","closestTotal","closestPosition","bestPath","_v","path","totalOutput","splice","v2","has","newIncome","isFinite","newGasSpent","newTotal","st","_closestVert2","name","findBestPathExactOut","_v2","totalInput","fn","_closestVert4","addPath","_from","getPrimaryPriceForPath","prevToken","edgePrice","findBestRouteExactIn","mode","routeValues","Array","isArray","sum","reduce","primaryPrice","step","status","gasSpentInit","totalrouted","NoWay","fromToken","toToken","amountInBN","amountOutBN","legs","totalAmountOut","totalAmountOutBN","Partial","Success","swapPrice","priceImpact","fromVert","toVert","getRouteLegs","topologyWasChanged","calcLegsAmountOut","findBestRouteExactOut","calcLegsAmountIn","cleanTopology","n","outEdges","_this7","edgeFrom","amount","total","quantity","poolAddress","poolFee","tokenFrom","tokenTo","assumedAmountIn","assumedAmountOut","swapPortion","absolutePortion","amounts","l","_this8","find","inputTotal","vertNext","prevAmount","totalOutputAssumed","prevValue","_this9","outputTotal","totalAssumed","_loop3","result","topologySort","removeWeakestEdge","removeDeadEnds","verts","minVert","minVertNext","minOutput","MAX_VALUE","vertState","vertsFinished","foundCycle","foundDeadEndVerts","topSortRecursive","current","state","successors2Exist","reverse","calcBestFlowNumber","bestSingleRoute","gasPriceIn","route","oneMinusCombinedFee","calcPriceImactWithoutFee","bestFlowAmount","bestFlowNumber","Pool","_info","info","type","RConstantProductPool","_Pool","ConstantProduct","RHybridPool","Hybrid","RWeightedPool","Weighted","weight0","weight1","RConcentratedLiquidityPool","ConcentratedLiquidity","DCacheBN","HybridComputeLiquidity","HybridgetY","OutOfLiquidity","Error","weightRatio","hPool","on","priceEffective","calcInputByPriceConstantMean","sqrtD","g","flows","fromV","outSingle","route1","route2","inSingle","getBetterRouteExactOut"],"mappings":"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"}